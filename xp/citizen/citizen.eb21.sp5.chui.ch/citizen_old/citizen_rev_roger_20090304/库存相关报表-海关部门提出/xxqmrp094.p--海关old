/* xxqmrp094.p 成品/材料库存报表,按输入日期的BOM,展开成原材料               */
/* Copyright 1986-2002 QAD Inc., Carpinteria, CA, USA.                      */
/* All rights reserved worldwide.  This is an unpublished work.             */
/*V8:ConvertMode=NoConvert                                                  */
/* REVISION: 1.0      Create : 2008/05/20   BY: Softspeed RogerXiao         */

/****************************************************************************/



{mfdtitle.i "1+ "}

/*define temp table for a6ppptrp0701.p*/
{a6ppptrp0701.i "new"}

DEFINE TEMP-TABLE tta6ictrrp0303
    FIELD tta6ictrrp0303_inv_nbr LIKE tr_rmks
    FIELD tta6ictrrp0303_nbr LIKE tr_nbr
    FIELD tta6ictrrp0303_line LIKE tr_line
    FIELD tta6ictrrp0303_site LIKE tr_site
    FIELD tta6ictrrp0303_pl LIKE tr_prod_line
    FIELD tta6ictrrp0303_part LIKE tr_part
    FIELD tta6ictrrp0303_trnbr LIKE tr_trnbr
    FIELD tta6ictrrp0303_traddr LIKE tr_addr
    FIELD tta6ictrrp0303_lot LIKE tr_lot
    FIELD tta6ictrrp0303_effdate LIKE tr_effdate
    FIELD tta6ictrrp0303_date LIKE tr_date
    FIELD tta6ictrrp0303_type LIKE tr_type
    FIELD tta6ictrrp0303_loc LIKE tr_loc
    FIELD tta6ictrrp0303_qty_dr LIKE tr_qty_loc
    FIELD tta6ictrrp0303_amt_dr LIKE trgl_gl_amt
    FIELD tta6ictrrp0303_qty_cr LIKE tr_qty_loc
    FIELD tta6ictrrp0303_amt_cr LIKE trgl_gl_amt
    FIELD tta6ictrrp0303_program LIKE tr_program /* add by: SS - 20070301.1 */
    FIELD tta6ictrrp0303_ship_type LIKE tr_ship_type                                                                      
    index index1 tta6ictrrp0303_part tta6ictrrp0303_type tta6ictrrp0303_trnbr
    index index2 tta6ictrrp0303_loc tta6ictrrp0303_part tta6ictrrp0303_type tta6ictrrp0303_trnbr
    index index3 tta6ictrrp0303_type
    index index4 tta6ictrrp0303_type tta6ictrrp0303_program tta6ictrrp0303_nbr
    index index5 tta6ictrrp0303_part
    .

DEF TEMP-TABLE tttr 
           FIELD tttr_part LIKE tr_part
           FIELD tttr_rct_loc LIKE tr_loc
           FIELD tttr_rct_trnbr LIKE tr_trnbr
           FIELD tttr_rct_qty_dr LIKE tr_qty_loc
           FIELD tttr_rct_amt_dr LIKE trgl_gl_amt
           FIELD tttr_iss_loc LIKE tr_loc
           FIELD tttr_iss_trnbr LIKE tr_trnbr
           FIELD tttr_iss_qty_dr LIKE tr_qty_loc
           FIELD tttr_iss_amt_dr LIKE trgl_gl_amt
           FIELD tttr_iss_integer AS INTEGER 
           FIELD tttr_rct_integer AS INTEGER 
           INDEX index1 tttr_part 
           .
DEF VAR v_rct_qty LIKE tr_qty_loc .
DEF VAR v_rct_amt LIKE trgl_gl_amt .
DEF VAR v_iss_qty LIKE tr_qty_loc .
DEF VAR v_iss_amt LIKE trgl_gl_amt .
DEF VAR v_rct_integer AS INTEGER .
DEF VAR v_iss_integer AS INTEGER .
DEF VAR v_log1 AS LOGICAL .
DEF VAR v_log2 AS LOGICAL .

define temp-table xxptstkrp02
    field xxptstkrp02_site			like pt_site     
	field xxptstkrp02_loc			like pt_loc 
	field xxptstkrp02_part			like pt_part
	field xxptstkrp02_desc1			like pt_desc1
	field xxptstkrp02_desc2			like pt_desc2
	field xxptstkrp02_um			like pt_um
	field xxptstkrp02_sct			as   decimal
	/*期初*/
	field xxptstkrp02_start_qty_oh		like ld_qty_oh		/*包含委托库存的库存量*/
	field xxptstkrp02_start_amt		like trgl_gl_amt
	field xxptstkrp02_start_cust_consi_qty	like ld_qty_oh		/*期初客户委托库存*/
	field xxptstkrp02_start_cust_consi_amt	like trgl_gl_amt
	/*field xxptstkrp02_start_supp_consi_qty	like ld_qty_oh		/*期初供应商委托库存*/
	field xxptstkrp02_start_supp_consi_amt	like trgl_gl_amt	*/
	/*入库及出库事务*/
	field xxptstkrp02_rctiss_qty		like ld_qty_oh   extent 60
	field xxptstkrp02_rctiss_amt		like trgl_gl_amt extent 60
	/*期末库存*/
	field xxptstkrp02_end_qty_oh		like ld_qty_oh		/*包含委托库存的库存量*/
	field xxptstkrp02_end_amt		like trgl_gl_amt
	field xxptstkrp02_end_cust_consi_qty	like ld_qty_oh		/*期初客户委托库存*/
	field xxptstkrp02_end_cust_consi_amt	like trgl_gl_amt
	/*field xxptstkrp02_end_supp_consi_qty	like ld_qty_oh		/*期初供应商委托库存*/
	field xxptstkrp02_end_supp_consi_amt	like trgl_gl_amt*/
	/*集团内部 外部进口 外部国内*/
    field xxptstkrp02_jtnb_rct_qty		like ld_qty_oh  /*集团内部采购*/
    field xxptstkrp02_wbjk_rct_qty		like ld_qty_oh
	field xxptstkrp02_wbgn_rct_qty		like ld_qty_oh
	field xxptstkrp02_jtnb_tmp_qty		like ld_qty_oh	/* 集团内部暂估 = 集团内部采购 - 集团内部发票 */
	field xxptstkrp02_wbjk_tmp_qty		like ld_qty_oh
	field xxptstkrp02_wbgn_tmp_qty		like ld_qty_oh
	field xxptstkrp02_jtnb_inv_qty		like ld_qty_oh	/*集团内部发票*/
	field xxptstkrp02_wbjk_inv_qty		like ld_qty_oh
	field xxptstkrp02_wbgn_inv_qty		like ld_qty_oh
	/*集团内部 外部进口 外部国内 金额*/
	field xxptstkrp02_jtnb_rct_amt		like trgl_gl_amt	/*集团内部采购*/
	field xxptstkrp02_wbjk_rct_amt		like trgl_gl_amt
	field xxptstkrp02_wbgn_rct_amt		like trgl_gl_amt
	field xxptstkrp02_jtnb_tmp_amt		like trgl_gl_amt	/* 集团内部暂估 = 集团内部采购 - 集团内部发票 */
	field xxptstkrp02_wbjk_tmp_amt		like trgl_gl_amt
	field xxptstkrp02_wbgn_tmp_amt		like trgl_gl_amt
	field xxptstkrp02_jtnb_inv_amt		like trgl_gl_amt	/*集团内部发票*/
	field xxptstkrp02_wbjk_inv_amt		like trgl_gl_amt
	field xxptstkrp02_wbgn_inv_amt		like trgl_gl_amt
	index index1  	xxptstkrp02_part.		/* Add By:  SS - 20070118.1 */


define var v_only_total as logical format "Yes - 仅汇总 /No - 仅明细" initial yes .
define temp-table temp99
	field t99_part			like pt_part
	field t99_desc1			like pt_desc1
	field t99_desc2			like pt_desc2
	field t99_um			like pt_um
	/*期初*/
	field t99_start_qty_oh		like ld_qty_oh	
	field t99_start_amt		    like trgl_gl_amt
	/*入库及出库事务*/
	field t99_rctiss_qty		like ld_qty_oh   extent 60
	field t99_rctiss_amt		like trgl_gl_amt extent 60
	/*期末库存*/
	field t99_end_qty_oh		like ld_qty_oh	
	field t99_end_amt		    like trgl_gl_amt .



/*存放入库事务及出库事务如	1 rct-po  2 rct-unp  3 iss-so  4 iss-wo 等等*/
define temp-table tt	
	field tt_integer	 as integer
	field tt_trtype		 as char 
	field tt_trtype_name as char 
    FIELD tt_class       AS CHAR 
	index index1 tt_integer tt_trtype .

define variable site     like prh_site     no-undo.
define variable site1    like prh_site     no-undo.
define variable loc	 like ld_loc       no-undo.
define variable loc1	 like ld_loc       no-undo.
define variable locgroup as char format "x(30)" .
define variable idate    like vph_inv_date no-undo.
define variable idate1   like vph_inv_date no-undo.
define variable line     like pt_prod_line no-undo.
define variable line1    like pt_prod_line no-undo.
define variable part     like prh_part     no-undo.
define variable part1    like prh_part     no-undo.
define variable vendor   like prh_vend     no-undo.
define variable vendor1  like prh_vend     no-undo.
define variable rcttype as char .
define variable ii as inte .
define variable maxii as inte .
define variable v_yn as logi.
define  variable buyer    like prh_buyer    no-undo.
define  variable buyer1   like prh_buyer    no-undo.
define  variable order    like prh_nbr      no-undo.
define  variable order1   like prh_nbr      no-undo.
define  variable sel_inv  like mfc_logical  no-undo
                          label "Inventory Items" initial yes.
define  variable sel_sub  like mfc_logical  no-undo
                          label "Subcontracted Items" initial yes.
define  variable sel_mem  like mfc_logical  no-undo
                          label "Memo Items" initial no.
define  variable sel_neg  like mfc_logical  no-undo
                                    label "Include Returns" initial no.

/*a6ppptrp0701 var*/
define variable abc		like pt_abc       no-undo.
define variable abc1		like pt_abc       no-undo.
define variable part_group    like pt_group     no-undo.
define variable part_group1   like pt_group     no-undo.
define variable part_type     like pt_part_type no-undo.
define variable part_type1    like pt_part_type no-undo.
define variable as_of_date        like tr_effdate no-undo.
define variable neg_qty       like mfc_logical initial yes
   label "Include Negative Inventory" no-undo.
define variable net_qty       like mfc_logical initial yes
   label "Include Non-nettable Inventory" no-undo.
define variable inc_zero_qty  like mfc_logical initial no
   label "Include Zero Quantity" no-undo.
define variable zero_cost     like mfc_logical initial yes
   label "Accept Zero Initial Cost" no-undo.

/* CONSIGNMENT VARIABLES */
{pocnvars.i}
{pocnvar2.i}

/*a6ictrrp0301*/
define variable glref  like trgl_gl_ref.
define variable glref1 like trgl_gl_ref.
define variable efdate like tr_effdate.
define variable efdate1 like tr_date.
define variable trtype like tr_type.
define variable entity like en_entity.
define variable entity1 like en_entity.
define variable acct like glt_acct.
define variable acct1 like glt_acct.
define variable sub like glt_sub.
define variable sub1 like glt_sub.
define variable proj like glt_project.
define variable proj1 like glt_project.
define variable cc like glt_cc.
define variable cc1 like glt_cc.
define variable trdate like tr_date.
define variable trdate1 like tr_date.
DEF VAR v_idate LIKE tr_date .

DEF TEMP-TABLE tt2 
    FIELD tt2_part LIKE tr_part
	field tt2_jtnb_rct_qty		like ld_qty_oh	/*集团内部采购*/
	field tt2_wbjk_rct_qty		like ld_qty_oh
	field tt2_wbgn_rct_qty		like ld_qty_oh
	field tt2_jtnb_inv_qty		like ld_qty_oh	/*集团内部发票*/
	field tt2_wbjk_inv_qty		like ld_qty_oh
	field tt2_wbgn_inv_qty		like ld_qty_oh
	field tt2_jtnb_rct_amt		like trgl_gl_amt	/*集团内部采购*/
	field tt2_wbjk_rct_amt		like trgl_gl_amt
	field tt2_wbgn_rct_amt		like trgl_gl_amt
	field tt2_jtnb_inv_amt		like trgl_gl_amt	/*集团内部发票*/
	field tt2_wbjk_inv_amt		like trgl_gl_amt
	field tt2_wbgn_inv_amt		like trgl_gl_amt
    INDEX ipart tt2_part
    .

DEF TEMP-TABLE tt3 
    FIELD tt3_type LIKE tr_type
    FIELD tt3_program LIKE tr_program
    FIELD tt3_nbr LIKE tr_nbr
    INDEX nbr1 tt3_type tt3_program tt3_nbr 
    .

def var v_jtnb_tmp_qty like ld_qty_oh.
def var v_wbjk_tmp_qty like ld_qty_oh.
def var v_wbgn_tmp_qty like ld_qty_oh.
def var v_jtnb_tmp_amt like trgl_gl_amt.
def var v_wbjk_tmp_amt like trgl_gl_amt.
def var v_wbgn_tmp_amt like trgl_gl_amt.


define variable p_part like pt_part.
define variable j as integer.
define variable qty_per like ps_qty_per.
define variable pm_code like pt_pm_code.
define variable eff__date as date label "生效日期".

define temp-table temp1
        field t1_par         like ps_par label "父零件" 
        field t1_comp        like ps_comp  label "子零件"
        field t1_um          like pt_um
        field t1_desc1       like pt_desc1
        field t1_desc2       like pt_desc2
        field t1_qty_per     like ps_qty_per
        index t1_parcomp     t1_par t1_comp.

/******************** SS - 20070308.1 - E ********************/

/* THE FIELD LABEL OF THE DATE SELECTION CHANGED FROM INVOICE DATE */
/* TO EFFECTIVE.                                                   */

idate1 = date (month(today),1,year(today)) - 1 .
idate  = date (month(idate1),1,year(idate1)) .
eff__date = idate1 .

FORM
   idate	label "Effective" colon 15      
   idate1	label "To"        colon 49 skip 
   site		colon 15               
   site1	label {t001.i} colon 49
   loc		colon 15               
   loc1		label {t001.i} colon 49
   /*locgroup	label "库位分组" colon 15*/
           

   /*line		colon 15                    
   line1	label {t001.i} colon 49 skip*/
   part		colon 15                    
   part1	label {t001.i} colon 49 skip
/*   vendor	colon 15                    
   vendor1	label {t001.i} colon 49 skip
*/
    skip(1)
    eff__date  colon 15 label "BOM生效日期"
    v_only_total colon 15 label "汇总/明细"
with frame a side-labels width 80 attr-space.

/* SET EXTERNAL LABELS */
setFrameLabels(frame a:handle).

{wbrp01.i}
repeat:
	hide all no-pause .
	view frame dtitle .
   if idate   = low_date then idate = ?.
   if idate1  = hi_date then idate1 = ?.
   if vendor1 = hi_char then vendor1 = "".
   if loc1    = hi_char then loc1  = "".
   if part1   = hi_char then part1 = "".
   if site1   = hi_char then site1 = "".
   if line1   = hi_char then line1 = "".
   if glref1 = hi_char then
      glref1 = "".
   if trdate = low_date then
      trdate = ?.
   if trdate1 = hi_date then
      trdate1 = ?.
   if acct1  = hi_char then
      acct1  = "".
   if sub1   = hi_char then
      sub1   = "".
   if cc1    = hi_char then
      cc1    = "".
   if proj1  = hi_char then
      proj1  = "".

   if c-application-mode <> 'web' then
      update
    	 idate	
    	 idate1	         
         site		
    	 site1	
    	 loc		
    	 loc1		
    	 /*locgroup	*/	              

    	 /*line		
    	 line1	*/
    	 part		
    	 part1	
    	 /*vendor	
    	 vendor1*/	
         eff__date
         v_only_total
      with frame a.

      if eff__date= ? then eff__date = date (month(today),1,year(today)) - 1 .

   {wbrp06.i &command = update &fields = " 
			 idate	
			 idate1
             site		
			 site1	
			 loc		
			 loc1			              
			 		
			 part		
			 part1	eff__date v_only_total
			     
		   " &frm = "a"}

   if (c-application-mode <> 'web') or
      (c-application-mode = 'web' and
      (c-web-request begins 'data'))
   then do:

      bcdparm = "".
      {mfquoter.i site	}
      {mfquoter.i site1	}
      {mfquoter.i loc	}
      {mfquoter.i loc1	}
      {mfquoter.i locgroup}
      {mfquoter.i idate	}
      {mfquoter.i idate1	}
      {mfquoter.i line	}
      {mfquoter.i line1	}
      {mfquoter.i part	}
      {mfquoter.i part1	}
        {mfquoter.i eff__date	}

      if idate = ? then idate = low_date.
      if idate1 = ? then idate1 = hi_date.
      if vendor1 = "" then vendor1 = hi_char.
      if part1 = "" then part1 = hi_char.
      if site1 = "" then site1 = hi_char.
      if loc1    = "" then loc1  = hi_char.
      if line1   = "" then line1 = hi_char.
      if glref1 = "" then
         glref1 = hi_char.
      if entity1 = "" then
         entity1 = hi_char.
      if acct1  = "" then
         acct1  = hi_char.
      if sub1   = "" then
         sub1   = hi_char.
      if cc1    = "" then
         cc1    = hi_char.
      if proj1  = "" then
         proj1  = hi_char.
      if trdate = ? then
         trdate = low_date.
      if trdate1 = ? then
         trdate1 = hi_date.

   end.
   /* OUTPUT DESTINATION SELECTION */
   {gpselout.i &printType = "printer"
               &printWidth = 132
               &pagedFlag = " "
               &stream = " "
               &appendToFile = " "
               &streamedOutputToTerminal = " "
               &withBatchOption = "yes"
               &displayStatementType = 1
               &withCancelMessage = "yes"
               &pageBottomMargin = 6
               &withEmail = "yes"
               &withWinprint = "yes"
               &defineVariables = "yes"}

	/*期初库存--BEGIN*/
	   FOR EACH tta6ppptrp0701:
	       DELETE tta6ppptrp0701.
	   END.
	
       /*
       PUT UNFORMATTED "a6ppptrp0701 begin: " + STRING(TIME, "HH:MM:SS") SKIP.
         */

	assign as_of_date = idate - 1 .		/*期初*/
	    {gprun.i ""a6ppptrp0701.p"" "(
		INPUT part,
		INPUT part1,
		INPUT LINE,
		INPUT line1,
		INPUT vendor,
		INPUT vendor1,
		INPUT abc,
		INPUT abc1,
		INPUT site,
		INPUT site1,
	    INPUT loc,
	    INPUT loc1,
		INPUT part_group,
		INPUT part_group1,
		INPUT part_type,
		INPUT part_type1,

		INPUT AS_of_date,
		INPUT neg_qty,
		INPUT net_qty,
		INPUT inc_zero_qty,
		INPUT zero_cost,
		INPUT customer_consign,
		INPUT supplier_consign
		)"}
		/* Remark By:  SS - 20061103.1 Begin ****
	EXPORT DELIMITER ";" "site" "loc" "part" "desc" "abc" "qty" "um" "sct" "ext" "Qty_none_consign" "Qty_supp_consign" "Qty_cust_consign".
        FOR EACH tta6ppptrp0701:
            EXPORT DELIMITER ";" tta6ppptrp0701.
        END.

        PUT UNFORMATTED "END: " + STRING(TIME, "HH:MM:SS") SKIP.
	****** Remark By:  SS - 20061103.1 End */

	FOR EACH tta6ppptrp0701:


        /*find first pt_mstr where pt_domain = global_domain and pt_part =  tta6ppptrp0701_part no-error .
        if not avail pt_mstr then next .
        else if pt_pm_code = "P" then next .
        else do:
            find first ps_mstr 
                where ps_domain = global_domain 
                and ps_par =  pt_part 
                /*and (eff__date = ? or (eff__date <> ? and
                    (ps_start = ? or ps_start <= eff__date)
                and (ps_end = ? or eff__date <= ps_end)))*/
            no-lock no-error .
            if not avail ps_mstr then next .
        end.  仅成品半成品*/



		
		/*判断是否在库位分组里--BEGIN*/
			run pro_locgroup(input tta6ppptrp0701_loc,locgroup,output v_yn).                        
			if v_yn = no then next .
		/*判断是否在库位分组里--END*/

		find first xxptstkrp02 
            where xxptstkrp02_part = tta6ppptrp0701_part 
            and xxptstkrp02_site = tta6ppptrp0701_site 
            and xxptstkrp02_loc = tta6ppptrp0701_loc  
        no-error.
		if avail xxptstkrp02 then do:
			assign xxptstkrp02_start_qty_oh		= xxptstkrp02_start_qty_oh + tta6ppptrp0701_qty_non_consign + tta6ppptrp0701_qty_cust_consign + tta6ppptrp0701_qty_supp_consign
			       xxptstkrp02_start_amt		= xxptstkrp02_start_amt + (tta6ppptrp0701_qty_non_consign + tta6ppptrp0701_qty_cust_consign + tta6ppptrp0701_qty_supp_consign) * tta6ppptrp0701_sct 
			       xxptstkrp02_start_cust_consi_qty = xxptstkrp02_start_cust_consi_qty + tta6ppptrp0701_qty_cust_consign
			       xxptstkrp02_start_cust_consi_amt = xxptstkrp02_start_cust_consi_amt + tta6ppptrp0701_qty_cust_consign * tta6ppptrp0701_sct .
		end.
		else do:      
			create xxptstkrp02.
			assign 
			       xxptstkrp02_part			= tta6ppptrp0701_part
                   xxptstkrp02_site         = tta6ppptrp0701_site 
                   xxptstkrp02_loc          = tta6ppptrp0701_loc 
			       xxptstkrp02_sct			= tta6ppptrp0701_sct
			       xxptstkrp02_start_qty_oh		= tta6ppptrp0701_qty_non_consign + tta6ppptrp0701_qty_cust_consign + tta6ppptrp0701_qty_supp_consign
			       xxptstkrp02_start_amt		= (tta6ppptrp0701_qty_non_consign + tta6ppptrp0701_qty_cust_consign + tta6ppptrp0701_qty_supp_consign) * tta6ppptrp0701_sct 
			       xxptstkrp02_start_cust_consi_qty = tta6ppptrp0701_qty_cust_consign
			       xxptstkrp02_start_cust_consi_amt = tta6ppptrp0701_qty_cust_consign * tta6ppptrp0701_sct .
		end.
	END.
	/*期初库存--END*/
	
	/*期末库存--BEGIN*/
	   FOR EACH tta6ppptrp0701:
	       DELETE tta6ppptrp0701.
	   END.
	
	assign as_of_date = idate1 .		
	    {gprun.i ""a6ppptrp0701.p"" "(
		INPUT part,
		INPUT part1,
		INPUT LINE,
		INPUT line1,
		INPUT vendor,
		INPUT vendor1,
		INPUT abc,
		INPUT abc1,
		INPUT site,
		INPUT site1,
	    INPUT loc,
	    INPUT loc1,
		INPUT part_group,
		INPUT part_group1,
		INPUT part_type,
		INPUT part_type1,

		INPUT AS_of_date,
		INPUT neg_qty,
		INPUT net_qty,
		INPUT inc_zero_qty,
		INPUT zero_cost,
		INPUT customer_consign,
		INPUT supplier_consign
		)"}
	/* Remark By:  SS - 20061103.1 Begin *****
	EXPORT DELIMITER ";" "site" "loc" "part" "desc" "abc" "qty" "um" "sct" "ext" "Qty_none_consign" "Qty_supp_consign" "Qty_cust_consign".
        FOR EACH tta6ppptrp0701:
            EXPORT DELIMITER ";" tta6ppptrp0701.
        END.

        PUT UNFORMATTED "END: " + STRING(TIME, "HH:MM:SS") SKIP.
	***** Remark By:  SS - 20061103.1 End */
	
	FOR EACH tta6ppptrp0701:

        /*find first pt_mstr where pt_domain = global_domain and pt_part =  tta6ppptrp0701_part no-error .
        if not avail pt_mstr then next .
        else if pt_pm_code = "P" then next .
        else do:
            find first ps_mstr 
                where ps_domain = global_domain 
                and ps_par =  pt_part 
                /*and (eff__date = ? or (eff__date <> ? and
                    (ps_start = ? or ps_start <= eff__date)
                and (ps_end = ? or eff__date <= ps_end)))*/
            no-lock no-error .
            if not avail ps_mstr then next .
        end.  仅成品半成品*/


		/*判断是否在库位分组里--BEGIN*/
        run pro_locgroup(input tta6ppptrp0701_loc,locgroup,output v_yn).
        if v_yn = no then next .
		/*判断是否在库位分组里--END*/
		find first xxptstkrp02 
            where xxptstkrp02_part = tta6ppptrp0701_part 
            and xxptstkrp02_site   = tta6ppptrp0701_site 
            and xxptstkrp02_loc    = tta6ppptrp0701_loc  
        no-error.
		if avail xxptstkrp02 then do:
			assign xxptstkrp02_end_qty_oh	        = xxptstkrp02_end_qty_oh + tta6ppptrp0701_qty_non_consign + tta6ppptrp0701_qty_cust_consign + tta6ppptrp0701_qty_supp_consign
			       xxptstkrp02_end_amt	            = xxptstkrp02_end_amt + (tta6ppptrp0701_qty_non_consign + tta6ppptrp0701_qty_cust_consign + tta6ppptrp0701_qty_supp_consign) * tta6ppptrp0701_sct 
			       xxptstkrp02_end_cust_consi_qty   = xxptstkrp02_end_cust_consi_qty + tta6ppptrp0701_qty_cust_consign
			       xxptstkrp02_end_cust_consi_amt   = xxptstkrp02_end_cust_consi_amt + tta6ppptrp0701_qty_cust_consign * tta6ppptrp0701_sct .
		end.		
	END.
	/*期末库存--END*/

    /*
    PUT UNFORMATTED "a6ppptrp0701 end: " + STRING(TIME, "HH:MM:SS") SKIP.
      */

	for each tta6ictrrp0303:
        delete tta6ictrrp0303.
    end.

    /*
    put unformatted "tr_hist begin: " + string(time, "hh:mm:ss") skip.
      */
	assign efdate = idate
	       efdate1 = idate1 .   
    for each tr_hist field( tr_rmks tr_nbr tr_line tr_site tr_prod_line tr_part tr_trnbr tr_addr tr_lot tr_effdate
                            tr_date tr_type tr_loc tr_program tr_qty_loc )
          where tr_hist.tr_domain = global_domain
          and tr_part >= part and tr_part <= part1
          and tr_ship_type = ""
          and tr_loc >= loc and tr_loc <= loc1
          and tr_site >= site and tr_site <= site1
          and tr_prod_line >= line
          and tr_prod_line <= line1
          and ( (tr_effdate >= efdate and tr_effdate <= efdate1 
                 or tr_effdate = ?)
          and (tr_type = trtype or trtype = "")
          and (tr_date >= trdate and tr_date <= trdate1
                 or tr_date = ?) ) no-lock ,
          each trgl_det field( trgl_dr_acct trgl_gl_amt)  where trgl_det.trgl_domain = global_domain 
          and ( trgl_trnbr = tr_trnbr
          and ( trgl_gl_ref  >= glref  and trgl_gl_ref  <= glref1)
          and (
                (trgl_dr_acct >= acct and trgl_dr_acct <= acct1)
                or (trgl_cr_acct >= acct and trgl_cr_acct <= acct1)
              )
         and (
                (trgl_dr_sub >= sub and trgl_dr_sub <= sub1)
                or (trgl_cr_sub >= sub and trgl_cr_sub <= sub1)
             )
         and (
                (trgl_dr_cc >= cc and trgl_dr_cc <= cc1)
                or (trgl_cr_cc >= cc and trgl_cr_cc <= cc1)

             )
         and (
                (trgl_dr_proj >= proj and trgl_dr_proj <= proj1)
                or (trgl_cr_proj >= proj and trgl_cr_proj <= proj1)
              )  )no-lock  break by tr_type by tr_part by tr_site by tr_loc:

        /*find first pt_mstr where pt_domain = global_domain and pt_part =  tr_part no-error .
        if not avail pt_mstr then next .
        else if pt_pm_code = "P" then next .
        else do:
            find first ps_mstr 
                where ps_domain = global_domain 
                and ps_par =  pt_part 
                /*and (eff__date = ? or (eff__date <> ? and
                    (ps_start = ? or ps_start <= eff__date)
                and (ps_end = ? or eff__date <= ps_end)))*/
            no-lock no-error .
            if not avail ps_mstr then next .
        end.  仅成品半成品*/

           create tta6ictrrp0303.
           assign
               tta6ictrrp0303_inv_nbr = tr_rmks
               tta6ictrrp0303_nbr     = tr_nbr
               tta6ictrrp0303_line    = tr_line
               tta6ictrrp0303_site    = tr_site
               tta6ictrrp0303_pl      = tr_prod_line
               tta6ictrrp0303_part    = tr_part
               tta6ictrrp0303_trnbr   = tr_trnbr
               tta6ictrrp0303_traddr  = tr_addr
               tta6ictrrp0303_lot     = tr_lot
               tta6ictrrp0303_effdate = tr_effdate
               tta6ictrrp0303_date    = tr_date
               tta6ictrrp0303_type    = tr_type
               tta6ictrrp0303_loc     = tr_loc
               tta6ictrrp0303_program = tr_program /* add by: ss - 20070301.1 */
               .
           if  (trgl_dr_acct >= acct and trgl_dr_acct <= acct1) then do:
               assign
                   tta6ictrrp0303_qty_dr = tr_qty_loc
                   tta6ictrrp0303_amt_dr = trgl_gl_amt
                   .
           end.
           else do:
               assign
                   tta6ictrrp0303_qty_cr = tr_qty_loc
                   tta6ictrrp0303_amt_cr = - trgl_gl_amt
                   .
           end.
           if first-of(tr_type) then do:
                find first tt3 where tt3_type = tr_type  no-error.
                if not avail tt3 then do:
                   create tt3 .
                   assign 
                       tt3_type = tr_type 
                       .
                end.
           end.
           if first-of(tr_loc) then do:
                find first xxptstkrp02 
                    where xxptstkrp02_part = tr_part 
                    and xxptstkrp02_site   = tr_site 
                    and xxptstkrp02_loc    = tr_loc  
                no-error.
                if not avail xxptstkrp02 then do:
                    create xxptstkrp02.
                    assign 
                        xxptstkrp02_part   = tr_part
                        xxptstkrp02_site   = tr_site 
                        xxptstkrp02_loc    = tr_loc .                          
                end.
           end.
    end.

    /*
    PUT UNFORMATTED "tr_hist end: " + STRING(TIME, "HH:MM:SS") SKIP.
      */

	/* Remark By:  SS - 20061103.1 Begin **** */
            /*
	    EXPORT DELIMITER ";" "inv_nbr" "nbr" "line" "site" "pl" "part" "wo_part" "trnbr" "traddr" "lot" "effdate" "date" "type" "loc" "acct" "sub" "cc" "proj" "qty_dr" "amt_dr" "qty_cr" "amt_cr".
        FOR EACH tta6ictrrp0303:
            EXPORT DELIMITER ";" tta6ictrrp0303.
        END.
             
        PUT UNFORMATTED "END: " + STRING(TIME, "HH:MM:SS") SKIP.
	          */
	/***** Remark By:  SS - 20061103.1 End */

    /*
    PUT UNFORMATTED "tt3 begin: " + STRING(TIME, "HH:MM:SS") SKIP.
      */

    ii = 1 .
    FOR EACH tt3 WHERE (tt3_type = "CYC-RCNT" OR tt3_type = "TAG-CNT") BREAK BY tt3_type :
        if first-of(tt3_type) then do:
			create  tt .
			assign	tt_integer = ii 
				tt_trtype  = tt3_type
                tt_class = "TYPE" .
			ii = ii + 1 .
		end.
    END.
	for each tt3 where tt3_type >= "RCT" and tt3_type <= "RCTZ" 
                   AND tt3_type <> "RCT-TR" 
                   break by tt3_type:
		if first-of(tt3_type) then do:
			create  tt .
			assign	tt_integer = ii 
				tt_trtype  = tt3_type
                tt_class = "TYPE" .
			ii = ii + 1 .
		end.
	end.
	for each tt3 where tt3_type = "RCT-TR"  break by tt3_type :
		if first-of(tt3_type) then do:
			create  tt .
			assign	tt_integer = ii 
				    tt_trtype  = "RCT-TR "  
                    tt_class = "TYPE" .
			ii = ii + 1 .
		end.
	end.   

	for each tt3 where tt3_type >= "ISS" and tt3_type <= "ISSZ" 
                   AND tt3_type <> "ISS-TR" 
                   break by tt3_type:
		if first-of(tt3_type) then do:
			create tt .
			ASSIGN 
                tt_integer = ii 
				tt_trtype  = tt3_type
                tt_class = "TYPE" .
			ii = ii + 1 .
		end.
	end.
	for each tt3 WHERE tt3_type = "ISS-TR"  break by tt3_type :
		if first-of(tt3_type) then do:
			create  tt .
			assign	tt_integer = ii 
			        tt_trtype  = "ISS-TR " 
                    tt_class = "TYPE"  .
			ii = ii + 1 .
		end.
	end.

	maxii = ii - 1 .

    /*
    PUT UNFORMATTED "tt3 end: " + STRING(TIME, "HH:MM:SS") SKIP.
      */
    /*
    PUT UNFORMATTED "xxptrstkrp02 begin: " + STRING(TIME, "HH:MM:SS") SKIP.
      */

    FOR EACH tttr :
        DELETE tttr .
    END.

	FOR EACH xxptstkrp02 break by xxptstkrp02_site by xxptstkrp02_loc  by xxptstkrp02_part :
        /* cyc-rcnt tag-cnt  B*/
        FOR EACH tta6ictrrp0303 FIELD(tta6ictrrp0303_part tta6ictrrp0303_type tta6ictrrp0303_loc
                                 tta6ictrrp0303_trnbr tta6ictrrp0303_qty_dr tta6ictrrp0303_amt_dr)
            WHERE tta6ictrrp0303_part = xxptstkrp02_part 
            and tta6ictrrp0303_site = xxptstkrp02_site 
            and tta6ictrrp0303_loc = xxptstkrp02_loc 
            AND (tta6ictrrp0303_type = 'CYC-RCNT' OR tta6ictrrp0303_type = 'TAG-CNT') 
            BREAK by tta6ictrrp0303_type by tta6ictrrp0303_trnbr :
                /*判断是否在库位分组里--BEGIN*/
                run pro_locgroup(input tta6ictrrp0303_loc,locgroup,output v_yn).
                if v_yn = no then next .            
                if not (tta6ictrrp0303_loc >= loc and tta6ictrrp0303_loc <= loc1) then next .
                /*判断是否在库位分组里--END*/
                find first tt where tt_trtype = tta6ictrrp0303_type no-error.
                if not avail tt then next .
                else do:         
                    if first-of(tta6ictrrp0303_trnbr) then
                        assign xxptstkrp02_rctiss_qty[tt_integer] = xxptstkrp02_rctiss_qty[tt_integer] + tta6ictrrp0303_qty_dr .
                        assign xxptstkrp02_rctiss_amt[tt_integer] = xxptstkrp02_rctiss_amt[tt_integer] + tta6ictrrp0303_amt_dr .
                end.
                DELETE tta6ictrrp0303 .
        END.
        /* cyc-rcnt tag-cnt  E*/

		/*本月入库事务--BEGIN*/
		for each tta6ictrrp0303 FIELD(tta6ictrrp0303_part tta6ictrrp0303_type tta6ictrrp0303_loc tta6ictrrp0303_nbr
                                      tta6ictrrp0303_trnbr tta6ictrrp0303_qty_dr tta6ictrrp0303_amt_dr tta6ictrrp0303_program ) 
                                where tta6ictrrp0303_part = xxptstkrp02_part
                                and tta6ictrrp0303_site = xxptstkrp02_site 
                                and tta6ictrrp0303_loc = xxptstkrp02_loc 
				                  and ((tta6ictrrp0303_type >= "RCT" and tta6ictrrp0303_type <= "RCTZ") /* OR tta6ictrrp0303_type = "ISS-PRV" */ )
			                      break BY tta6ictrrp0303_type by tta6ictrrp0303_trnbr :
			/*判断是否在库位分组里--BEGIN*/
				run pro_locgroup(input tta6ictrrp0303_loc,locgroup,output v_yn).
				if v_yn = no then next .            
				if not (tta6ictrrp0303_loc >= loc and tta6ictrrp0303_loc <= loc1) then next .
			/*判断是否在库位分组里--END*/

    			find first tt where tt_trtype = tta6ictrrp0303_type no-error.
    			if not avail tt then next .
    			else do:         
    				if first-of(tta6ictrrp0303_trnbr) then
    					assign xxptstkrp02_rctiss_qty[tt_integer] = xxptstkrp02_rctiss_qty[tt_integer] + tta6ictrrp0303_qty_dr .
    			    assign xxptstkrp02_rctiss_amt[tt_integer] = xxptstkrp02_rctiss_amt[tt_integer] + tta6ictrrp0303_amt_dr .
    			end.
                
                DELETE tta6ictrrp0303 .
		end.		
		/*本月入库事务--END*/

		/*本月出库事务--BEGIN*/
		for each tta6ictrrp0303 FIELD(tta6ictrrp0303_part tta6ictrrp0303_type tta6ictrrp0303_loc tta6ictrrp0303_nbr
                                      tta6ictrrp0303_trnbr tta6ictrrp0303_qty_dr tta6ictrrp0303_amt_dr tta6ictrrp0303_program )
                                where tta6ictrrp0303_part = xxptstkrp02_part
                                and tta6ictrrp0303_site = xxptstkrp02_site 
                                and tta6ictrrp0303_loc = xxptstkrp02_loc 
				                  and tta6ictrrp0303_type >= "ISS" and tta6ictrrp0303_type <= "ISSZ"
			                      BREAK by tta6ictrrp0303_type by tta6ictrrp0303_trnbr :
			/*判断是否在库位分组里--BEGIN*/         
				run pro_locgroup(input tta6ictrrp0303_loc,locgroup,output v_yn).
				if v_yn = no then next .               
				if not (tta6ictrrp0303_loc >= loc and tta6ictrrp0303_loc <= loc1) then next .            
			/*判断是否在库位分组里--END*/

    			find first tt where tt_trtype = tta6ictrrp0303_type no-error.
    			if not avail tt then next .
    			else do:
    				if first-of(tta6ictrrp0303_trnbr) then
    					assign xxptstkrp02_rctiss_qty[tt_integer] = xxptstkrp02_rctiss_qty[tt_integer] + tta6ictrrp0303_qty_dr .
    				assign xxptstkrp02_rctiss_amt[tt_integer] = xxptstkrp02_rctiss_amt[tt_integer] + tta6ictrrp0303_amt_dr .
    			end.

                DELETE tta6ictrrp0303 .
		end.		
		/*本月出库事务--END*/           

	END.  /*End for each xxptstkrp02*/
    /*
    PUT UNFORMATTED "xxptrstkrp02 end: " + STRING(TIME, "HH:MM:SS") SKIP.
      */                      

for each temp1 : delete temp1. end.
FOR EACH xxptstkrp02 break by xxptstkrp02_part :
    if last-of(xxptstkrp02_part) then do:
            p_part  = xxptstkrp02_part .
            pm_code = "" .
            run process_report (input p_part).
    end.
end.

for each temp99 : delete temp99 . end.


	PUT UNFORMATTED "#def REPORTPATH=$/Citizen/xxqmrp094" SKIP.
	PUT UNFORMATTED "#def :end" SKIP.   
	define variable max_BI_Field_pcs as inte init 51 .
	max_BI_Field_pcs = 51 .
    /*PUT UNFORMATTED "#define column1 as char[18]" SKIP. */
    PUT UNFORMATTED		"地点;"	.
    PUT UNFORMATTED		"库位;"	.
	PUT UNFORMATTED		"(半)成品编号;"	.
	PUT UNFORMATTED		"名称;"	.
	PUT UNFORMATTED		"规格;"	.
	PUT UNFORMATTED		"计量单位;"	.
        PUT UNFORMATTED		"材料编号;"	.
        PUT UNFORMATTED		"名称;"	.
        PUT UNFORMATTED		"规格;"	.
        PUT UNFORMATTED		"计量单位;"	.
	PUT UNFORMATTED		"期初数量;"	.
	for each tt by tt_integer:
    			/*find first code_mstr where code_domain = global_domain and code_fldname = "tr_type" and code_value = tt_trtype no-lock no-error.
    			if avail code_Mstr then assign tt_trtype_name = code_cmmt .
    			else */
                assign tt_trtype_name = tt_trtype .         
		PUT UNFORMATTED tt_trtype_name + "数量;"   .
	end.
	PUT UNFORMATTED	"期未结存数量"			.

/*	DO ii = 1 to max_BI_Field_pcs - (8 + maxii) - 1 :
		PUT UNFORMATTED ";" .
	END. */
	put skip .

	FOR EACH xxptstkrp02 ,
        EACH pt_mstr WHERE pt_domain = GLOBAL_domain AND pt_part = xxptstkrp02_part NO-LOCK ,
        each temp1 where t1_par = pt_part 
        break by xxptstkrp02_site by xxptstkrp02_loc  by xxptstkrp02_part 
        :   

        
        v_log1 = NO .
        v_log2 = NO .
        IF (xxptstkrp02_start_qty_oh <> 0 OR
            xxptstkrp02_end_qty_oh <> 0 ) THEN v_log1 = YES .
        IF maxii >= 1 THEN DO:
            DO ii = 1 TO maxii :
                IF xxptstkrp02_rctiss_qty[ii] <> 0 THEN v_log2 = YES.
            END.
        END.

        IF v_log1 = YES OR v_log2 = YES THEN DO:
            if v_only_total = no then do:
                PUT UNFORMATTED xxptstkrp02_site			  ";" .
                PUT UNFORMATTED xxptstkrp02_loc			  ";" .
                PUT UNFORMATTED xxptstkrp02_part			  ";" .
                PUT UNFORMATTED pt_desc1			  ";" .
                PUT UNFORMATTED pt_desc2			  ";" .
                PUT UNFORMATTED pt_um			  ";" .
                PUT UNFORMATTED t1_comp			  ";" .
                PUT UNFORMATTED t1_desc1			  ";" .
                PUT UNFORMATTED t1_desc2			  ";" .
                PUT UNFORMATTED t1_um			  ";" .
                PUT UNFORMATTED xxptstkrp02_start_qty_oh  * t1_qty_per	  ";" .
                if maxii >= 1 THEN do:
                    DO ii = 1 to maxii:
                            IF xxptstkrp02_rctiss_qty[ii] >= 0 THEN DO:
                                 PUT UNFORMATTED xxptstkrp02_rctiss_qty[ii]	 * t1_qty_per	";" .
                            END.
                            ELSE DO:
                                 PUT UNFORMATTED xxptstkrp02_rctiss_qty[ii] * t1_qty_per		";" .
                            END.
                    END.   
                end.
                PUT UNFORMATTED xxptstkrp02_end_qty_oh	 * t1_qty_per		. 
                /*DO ii = 1 to max_BI_Field_pcs - (8 + maxii) - 1 :
                    PUT UNFORMATTED ";" .
                END.   */
                put skip .
            end.

            find first temp99 where t99_part = t1_comp	no-error .
            if not avail temp99 then do:
                create temp99 .
                assign 
                    t99_part     = t1_comp
                    t99_desc1    = t1_desc1
                    t99_desc2    = t1_desc2
                    t99_um       = t1_um
                    t99_start_qty_oh  = xxptstkrp02_start_qty_oh  * t1_qty_per 
                    t99_end_qty_oh = xxptstkrp02_end_qty_oh	 * t1_qty_per	
                    .
                    if maxii >= 1 then do:
                        do ii = 1 to maxii:
                            t99_rctiss_qty[ii] =  xxptstkrp02_rctiss_qty[ii]	 * t1_qty_per .                               
                        end.   
                    end.
            end.
            else do:
                    assign 
                    t99_start_qty_oh  = t99_start_qty_oh + xxptstkrp02_start_qty_oh  * t1_qty_per 
                    t99_end_qty_oh = t99_end_qty_oh + xxptstkrp02_end_qty_oh	 * t1_qty_per	
                    .
                    if maxii >= 1 then do:
                        do ii = 1 to maxii:
                            t99_rctiss_qty[ii] = t99_rctiss_qty[ii] + xxptstkrp02_rctiss_qty[ii] * t1_qty_per .                               
                        end.   
                    end.                
            end.


        END. 


    END.
if v_only_total = yes then do:
    for each temp99:
            PUT UNFORMATTED 	  "零件总计;;;;;;" .
            PUT UNFORMATTED t99_part			  ";" .
            PUT UNFORMATTED t99_desc1			  ";" .
            PUT UNFORMATTED t99_desc2			  ";" .
            PUT UNFORMATTED t99_um			  ";" .
    	    PUT UNFORMATTED t99_start_qty_oh    ";" .
            if maxii >= 1 THEN do:
                DO ii = 1 to maxii:
                        PUT UNFORMATTED t99_rctiss_qty[ii]	";" .
                END.   
            end.
    	    PUT UNFORMATTED t99_end_qty_oh			. 
    		put skip .       
    end.
end.



    for each tt:
        delete tt.
    end.
    for each tt2:
        delete tt2.
    end.
    for each tt3:
        delete tt3.
    end.

    FOR EACH xxptstkrp02 :
        delete xxptstkrp02 .
    end.

    for each temp1 :
        delete temp1 .
    end.
    for each temp99 : delete temp99 . end.
    {a6mfrtrail.i}

end.

{wbrp04.i &frame-spec = a}








/*********************************************************************/



procedure pro_locgroup:
    define input parameter pro_loc as char .
    define input parameter pro_locgroup as char .
    define output parameter pro_yesno as logi .
    
    define variable prov_1 as char extent 20 .
    define variable prov_2 as char extent 20 .
    define variable jj as inte  .
    define variable kk as inte .
    define variable yn as logi .
    define variable iiii as inte .
    define variable loc33 as char extent 10 .

	pro_yesno = no .

	find code_mstr  where code_mstr.code_domain = global_domain and
			code_fldname = "locgroup"
                    and code_value = pro_locgroup no-lock no-error.
	if avail code_mstr then do:
		DO iiii = 1 to 10 :
			assign loc33[iiii] = substring(code_cmmt, (iiii - 1) * 60 + 1 ,60) .
		END.

		DO iiii = 1 to 10 :
			assign pro_locgroup = loc33[iiii]  .
			
			if pro_locgroup <> "" and pro_yesno = no then do:
				jj = 1 .
				yn = no .		
				DO kk = 1 to 20 :
					assign  prov_1[kk] = "" 
						prov_2[kk] = "" .
				END.  /* END DO */
				DO kk = 1 to length(pro_locgroup) :
					if substr(pro_locgroup,kk,1) <> "" then do:
						if substr(pro_locgroup,kk,1) = "-" then do:
							assign yn = yes 
								prov_2[jj] = "" .
						end.
						else if substr(pro_locgroup,kk,1) = "," then do:
							assign yn = no .
							if kk <> length(pro_locgroup) then assign jj = jj + 1 .
						end.
						else do:
							if yn = no then 
								assign prov_1[jj] = prov_1[jj] + substr(pro_locgroup,kk,1)
								       prov_2[jj] = prov_2[jj] + substr(pro_locgroup,kk,1) .
							else assign    prov_2[jj] = prov_2[jj] + substr(pro_locgroup,kk,1) .
						end.
					end.
				END.  /* END DO */
				do kk = 1 to jj + 1:
				/*disp prov_1[kk]
				     prov_2[kk] .*/
					
					if pro_loc >= prov_1[kk] and pro_loc <= prov_2[kk] then assign pro_yesno = yes .
					
				end.
			end.                  
		END.      
	end.	/*如果分组有效*/
	else assign pro_yesno = yes .   
end.


/*--------------------------------------------------------------------------------------------------------*/


                
         
procedure process_report:
   /*needed variables : eff__date pm_code qty_per j p_part  */
   define input parameter comp like ps_comp no-undo.

find first pt_mstr where pt_domain = global_domain and pt_part =  comp no-error .
if not avail pt_mstr then next .
else if pt_pm_code = "P" then do:
    create temp1 .
    assign
        t1_par      = comp
        t1_comp     = comp
        t1_desc1    = pt_desc1
        t1_desc2    = pt_desc2
        t1_um       = pt_um
        t1_qty_per  = 1
        .
end.
else do:
   for each ps_mstr no-lock
      where ps_domain = global_domain
        and ps_par = comp
        and (eff__date = ? or (eff__date <> ? and
            (ps_start = ? or ps_start <= eff__date)
        and (ps_end = ? or eff__date <= ps_end))):
     

        find first pt_mstr  where pt_domain = global_domain and pt_part = ps_comp no-lock no-error.      
        if available pt_mstr then pm_code = pt_pm_code.

        if ps_ps_code = "x" then pm_code = "p".

        qty_per = 1.
        if j = 1 then qty_per = ps_qty_per.
        else qty_per = qty_per * ps_qty_per.

        if pm_code = "p" then do:
            find first temp1 where t1_par = p_part and t1_comp = ps_comp no-error.
            if not available temp1 then do:
                create temp1.
                assign
                    t1_par      = p_part
                    t1_comp     = ps_comp
                    t1_desc1    = (if available pt_mstr then pt_desc1 else "")
                    t1_desc2    = (if available pt_mstr then pt_desc2 else "")
                    t1_um       = (if available pt_mstr then pt_um else "")
                    t1_qty_per  = qty_per
                    .
            end.
            else t1_qty_per   = t1_qty_per + qty_per.  
        
        end.  /*if pm_code = "p" */
        else do:
            j = j + 1.
            run process_report (input ps_comp).                   
        end.
   end. /*for each ps_mstr*/
end.  /*仅成品半成品*/
end procedure.
